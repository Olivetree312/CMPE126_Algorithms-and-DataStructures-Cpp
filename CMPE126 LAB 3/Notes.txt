Discuss the following questions for Task 1:
1. [LP] What constructors did you need to use? Is one constructor enough?
	I used the default constructor, a copy constructor, and the constructor that takes in all the
	parameters (month, day, year). In this case, we needed more than one constructor to support
	all the code.
	
2. [HP] What is the difference between lines 3 and 4?
	Line 3 and 4 use different constructors for the DateOfBirth type object.
	Line 4 is  copy constructor.
3. [HP] Explain how you are performing input validation for the Date and the DateOfBirth class.
	Both the Date and the DateOfBirth class have protected boolean functions that
	separately validate the day, month, and year. The setter functions have to call
	the boolean functions before assigning the values to the proper member. The
	isValidYear() function for the Date class is virtual because the DateOfBirth has
	different criteria for proper year.
4. [HP] What would be a good way to implement getAge without hard-coding todayâ€™s date?
	I, being superior to the heathens who hard-coded today's date, used functions from the
	<chronos> library. First, the line: 
	auto now = chrono::system_clock::now();
	gets the current time point in an internal clock format that is not readable by humans.
	Then, the line:
	time_t now_c = chrono::system_clock::to_time_t(now);
	converts the time point "now" to a time_t value, which converts it
	into an integer representing the seconds since epoch (January 1970).
	Then, we must place this integer into a tm struct,
	which contains separate fields for year, month, day, hour, min.
	In the next line, *localtime is dereferenced point so 
	the variable localTime now stores copy of tm struct now_c. This basically
	converts the time right now to the local time in the area in a human-readable format.
		tm localTime = *localtime(&now_c);
	The variable tm_year gives us the number of years since 1990, and we simply
	add it to 1990 to get today's date:
	int currYear = localTime.tm_year + 1900;
	
Discuss the following questions for Task 2:
1. [LP] What constructors did you need to use? Is one constructor enough?
	For the Passenger class, we didn't need to use more than one constructor
	to support the six lines of code, but I also included a default constructor
	because it's good practice. And also because I'm cool.
2. [HP] The fare_discount field is used to indicate if the passenger receives any discount on the
fare. This could be used for children or infants. How did you interpret the fare_discount field?
Is it necessary to use this field in the class? If not, what alternative would you use?
	I interpreted the fare_discount field as the percent discount granted
	to each passenger. I think it's necessary to use this field in the Passenger
	class, but we could alternatively just implement a "applyFareDiscount(double percent"
	function instead of storing the fare_discount for each passenger.
Discuss the following questions for Task 3:
1. [LP] What constructors did you need to use? Is one constructor enough?
	For the Time class, I used the default constructor, a constructor that
	took the hours as a parameter, and a constructor that took both the hour
	and the minute as parameters. One constructor is not enough to support
	the given lines of code.
2. [HP] What is the difference between lines 5 and 6? Do you need special implementation to
support line 6?
	Line 5 and 6 both use the overloaded operator << function I wrote, which
	takes in a reference to an ostream object and a reference to a Time object
	as parameters. However, Line 6 outputs two Time objects, which is possible
	because the overloaded operator function returns a reference to the ostream
	object taken in as a parameter, allowing for chaining.
Discuss the following questions for Task 4:
1. [LP] What constructors did you need to use? Is one constructor enough?
	For the Flight class, the code required us to use a constructor taking
	in the source and the destination as parameters. One constructor
	would be enough to support the code, but as mentioned above, I'm cool
	so I also put in a default constructor.
2. [HP] Do you need to overload the assignment operator for the Time class to support line 7? Why
or why not?
	I did not need to write an explicit overloaded assignment operator for the Time
	class because its hidden members were all of primitive int type, so the default
	assignment operator generated by the compiler is sufficient, as it correctly performs
	member-wise copying.
3. [HP] Did you need to do any input validation to support lines 3 and 4? What about line 7?
	I did not need to do any input validation to support lines 3 and 4, but I probably
	should have as a safe practice. However, line 7 did not require any input validation
	because the Time class has its own input validation.
Discuss the following questions for Task 5:
1. [LP] What constructors did you need to use? Is one constructor enough?
	For the Ticket class, the code only needed us to write one constructor
	with the parameters being the Passenger and the Flight objects. 
2. [HP] Consider the role of classes Time, Flight, Date, DateOfBirth, and Passenger in the
Ticket class. Was it necessary to use these many classes and inheritances? Briefly, in a short
paragraph, comment on the need for object-oriented design for a project like this.
	With the many classes involved in this project, object oriented design helps us code
	more efficiently through the principles of encapsulation, abstraction, inheritance,
	and polymorphism. Each of our classes had private members hidden from the other classes
	as well as methods and friend functions specific to their particular objects. Keeping
	the classes in separate header files helps us organize and bundle/ encapsulate the
	data specific to their type. In the main function, we don't have to write much code
	because all the complicated input validation and overloaded functions were already
	included in each class's file. Also, for the classes that inherited from each other,
	inheritance helps us avoid having to repeat code. Finally, runtime polymorphism
	allowed for us to use functions with the same name as well as redefine base class 
	functions.